[org 0x7c00]

; 文本模式清屏
mov ax, 3
int 0x10

; 初始化寄存器
mov ax, 0
mov ds, ax
mov es, ax
mov ss, ax
mov sp, 0x7c00

mov si, booting
call print

;----读取硬盘（第2扇区）并加载到内存（0x900)
mov eax,0x02	;起始扇区lba地址，LBA=(柱面号*磁头数+磁头号)*扇区数+扇区编号-1
mov ebx,0x1000    ;写入的内存地址，之后用
mov cx,4        ;待读入的扇区数
call read_disk

; 利用魔数检错
cmp word [0x1000], 0x55aa
jnz error

; 没有错误则跳转到loader
jmp 0x1002


;----读硬盘方法，eax为lba扇区号，ebx为待写入内存地址，cx为读入的扇区数
read_disk:
    push cx  ;备份
    push eax ;备份
	
;第一步，设置要读取的扇区数
	mov dx,0x1f2
	mov al,cl
	out dx,al
    
;第二步，设置LBA地址
    pop eax  ;恢复
	mov cl,8
	;0-7位写入0x1f3
	mov dx,0x1f3
	out dx,al
	;8-15位写入0x1f4
	mov dx,0x1f4
	shr eax,cl
	out dx,al
	;16-23位写入0x1f5
	mov dx,0x1f5
	shr eax,cl
	out dx,al
	;24-27位写入0x1f6
	mov dx,0x1f6
	shr eax,cl
	and al,0b1111	    ;保留lba的24-27位，另外4位置0
	or al,0b1110_0000	;另外4位为1110，表示lba模式
	out dx,al
	
;第三步，写入读命令
	mov dx,0x1f7
	mov al,0x20
	out dx,al

;第四步，检测硬盘状态
.not_ready:
	nop
	in al,dx
	and al,0b1001_0000	;第4位为1表示准备好，第7位为1表示忙
	cmp al,0b0001_0000
	jnz .not_ready
	
;第五步，读数据
    pop ax  ;恢复
	mov dx,256
	mul dx
	mov cx,ax
	
	mov dx,0x1f0
	.go_on_read:
		in ax,dx
		mov [ebx],ax
		add ebx,2
		loop .go_on_read
		ret

print:
    mov ah, 0x0e
    .next:
        mov al, [si]
        cmp al, 0
        jnz .put
        ret
    .put:
        int 0x10
        inc si
        jmp .next

booting:
    db "Booting OS...", 10, 13, 0   ; \n\r

error:
    mov si, .msg
    call print
    hlt; 让 CPU 停止
    jmp $
    .msg db "Booting Error!!!", 10, 13, 0

;引导区标识
times 510-($-$$) db 0
db 0x55, 0xaa